/**
 * Confluent Schema Registry
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.13.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "schemaregistry/rest/RestClient.h"

#include <cpr/cpr.h>

#include <chrono>
#include <iomanip>
#include <sstream>
#include <thread>

#include "schemaregistry/rest/BackoffUtils.h"
#include "schemaregistry/rest/OAuthProvider.h"

namespace schemaregistry::rest {

RestClient::RestClient(std::shared_ptr<const ClientConfiguration> configuration)
    : configuration_(configuration) {}
RestClient::~RestClient() {}

std::shared_ptr<const ClientConfiguration> RestClient::getConfiguration()
    const {
    return configuration_;
}

cpr::Response RestClient::sendRequestUrls(
    const std::string &path, const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    const auto &base_urls = configuration_->getBaseUrls();

    cpr::Response last_response;  // default constructed (status_code = 0)
    for (size_t i = 0; i < base_urls.size(); ++i) {
        try {
            auto result =
                tryRequest(base_urls[i], path, method, query, headers, body);

            last_response = result;

            // If successful response or non-retriable error, return it
            if (result.status_code == 0) {
                // Network error - try next URL if available
                if (i == base_urls.size() - 1) {
                    return result;  // Last URL, return the error
                }
                continue;
            } else if (result.status_code < 400 ||
                       !isRetriable(static_cast<int>(result.status_code))) {
                return result;
            } else if (i == base_urls.size() - 1) {
                // Last URL and retriable error, return it
                return result;
            }
            // Try next URL for retriable errors
        } catch (const std::exception &e) {
            if (i == base_urls.size() - 1) {
                return last_response;
            }
            // Try next URL for exceptions
        }
    }

    // This should never be reached, but return the last response
    return last_response;
}

cpr::Response RestClient::tryRequest(
    const std::string &base_url, const std::string &path,
    const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    std::uint32_t retries = 0;
    const std::uint32_t max_retries = configuration_->getMaxRetries();
    const std::uint32_t initial_wait_ms = configuration_->getRetriesWaitMs();
    const auto max_wait_ms =
        std::chrono::milliseconds(configuration_->getRetriesMaxWaitMs());

    while (true) {
        // Use the new sendRequest method that handles authentication and
        // headers
        cpr::Response result =
            sendRequest(base_url + path, method, query, headers, body);

        // Check if we should retry
        bool should_retry = false;
        if (result.status_code == 0) {
            // Network error - always retriable
            should_retry = true;
        } else if (result.status_code >= 400) {
            should_retry = utils::isRetriable(static_cast<int>(result.status_code));
        }

        if (!should_retry || retries >= max_retries) {
            return result;
        }

        // Apply exponential backoff with jitter
        auto backoff = utils::calculateExponentialBackoff(initial_wait_ms, retries,
                                                           max_wait_ms);
        std::this_thread::sleep_for(backoff);
        retries++;
    }
}

cpr::Response RestClient::sendRequest(
    const std::string &url, const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    std::unique_lock<std::mutex> lock(session_mutex_, std::defer_lock);

    auto session = configuration_->getSession();
    if (!session) {
        session = std::make_shared<cpr::Session>();
    } else {
        lock.lock();
    }

    // Configure the shared Session for this request
    // Ensure no stale body/payload leaks into requests like GET
    session->RemoveContent();
    session->SetUrl(cpr::Url{url});

    // Set default headers including content type
    cpr::Header cpr_headers;
    cpr_headers["Content-Type"] = "application/vnd.schemaregistry.v1+json";
    cpr_headers["Confluent-Accept-Unknown-Properties"] = "true";
    cpr_headers["Confluent-Client-Version"] = std::string("cpp/") + SCHEMAREGISTRY_VERSION;

    // Handle authentication (mutually exclusive methods)
    // Authentication methods are mutually exclusive - only one will be set.
    // Check in order: Basic Auth > OAuth Provider > Bearer Token
    // - Basic Auth: API Key/Secret authentication
    // - OAuth Provider: OAuth 2.0 with automatic token refresh
    // - Bearer Token: Static token (legacy, no refresh)
    const auto oauth_provider = configuration_->getOAuthProvider();
    const auto basic_auth = configuration_->getBasicAuth();
    const auto bearer_token = configuration_->getBearerAccessToken();

    if (basic_auth.has_value()) {
        // Basic authentication (API Key/Secret)
        session->SetAuth(cpr::Authentication{basic_auth.value().first,
                                             basic_auth.value().second,
                                             cpr::AuthMode::BASIC});
    } else if (oauth_provider) {
        // OAuth provider (automatic token management)
        try {
            BearerFields fields = oauth_provider->get_bearer_fields();

            // Set bearer token
            session->SetBearer(cpr::Bearer{fields.access_token});

            // Add Confluent Cloud headers required for OAuth
            cpr_headers["Confluent-Identity-Pool-Id"] = fields.identity_pool_id;
            cpr_headers["target-sr-cluster"] = fields.logical_cluster;
        } catch (const std::exception& e) {
            throw std::runtime_error(std::string("OAuth authentication failed: ") + e.what());
        }
    } else if (bearer_token.has_value()) {
        // Static bearer token (no auto-refresh)
        session->SetBearer(cpr::Bearer{bearer_token.value()});
    }

    // Add additional headers (can override defaults)
    for (const auto &kv : headers) {
        cpr_headers.insert(kv);
    }

    session->SetHeader(cpr_headers);

    // Set query parameters (supporting repeated keys)
    if (!query.empty()) {
        cpr::Parameters params{};
        for (const auto &p : query) {
            params.Add(cpr::Parameter{p.first, p.second});
        }
        session->SetParameters(params);
    }

    // Set body when applicable
    if (!body.empty() && (method == "POST" || method == "PUT" ||
                          method == "PATCH" || method == "DELETE")) {
        session->SetBody(cpr::Body{body});
    }

    // Dispatch based on method
    if (method == "GET") {
        return session->Get();
    } else if (method == "POST") {
        return session->Post();
    } else if (method == "PUT") {
        return session->Put();
    } else if (method == "PATCH") {
        return session->Patch();
    } else if (method == "DELETE") {
        return session->Delete();
    } else {
        // Unsupported method; set an error-like response
        return cpr::Response{};
    }
}

}  // namespace schemaregistry::rest
